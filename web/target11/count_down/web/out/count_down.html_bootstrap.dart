import "dart:isolate" as nE;import "dart:html" as m;import "dart:indexed_db" as RC;import "dart:async" as TB;import "dart:collection" as xB;class ME{static const  NE="Chrome";static const  OE="Firefox";static const  PE="Internet Explorer";static const  QE="Safari";final  CE;final  minimumVersion;const ME(this.CE,[this.minimumVersion]);}class RE{const RE();}class SE{final  name;const SE(this.name);}class TE{const TE();}class UE{const UE();}var UB=new oC(); nC(){}class oC{var mB=null;var IE=RC.IdbFactory.supported;var uE=new qC(); get HE=>(HB.length==0)?false:true; get HB=>uE.HB; start(){if(!IE){return new TB.Future.error('IndexedDB not supported.');}return uE.open().then((vE){wE();});} stop(){xE(true);} HC( h, g){if(g.isAfter(new DateTime.now())){uE.add(h,g).then((vE){wE();},onError:(i){print('duplicate key');});}} OC( g){return uE.remove(g).then((vE){xE(false);});} clear(){return uE.clear().then((vE){xE(false);});} wE(){if(mB==null&&HB.length>0){var g=new Duration(seconds:1);mB=new TB.Timer.periodic(g,yE);}} xE( g){if(g||(mB!=null&&HB.where((h)=>!h.elapsed).isEmpty)){mB.cancel();mB=null;}} yE( vE){for(int g=0;g<HB.length;g++ ){HB[g].JE();}}} pC(){var zE=m.document.body;var AF;var BF=new pB(zE);AF=zE.nodes[5];BF.YB(new VE()..host=AF);BF.QB();BF.insert();}main(){VC=true;nC();pC();}class MB extends t{final  fB;final  eB;var CF; get tB{if(s){w(this,k.q,'dbKey');}return CF;}set tB( g){if(CB(this)){n(this,k.q,'dbKey',CF,g);}CF=g;}var EF=new Duration(); get PC{if(s){w(this,k.q,'timeRemaining');}return EF;}set PC( g){if(CB(this)){n(this,k.q,'timeRemaining',EF,g);}EF=g;}MB(this.fB,this.eB); toString()=>'${fB} ${eB}';MB.oE(h, g):CF=h,fB=g['milestoneName'],eB=DateTime.parse(g['happensOn']){} LE(){return {'milestoneName':fB,'happensOn':eB.toString()};} get elapsed{return new DateTime.now().isAfter(eB);} JE(){PC=eB.difference(new DateTime.now());}}class qC{static const  KB='milestoneStore';static const  rC='name_index';final  HB=CD(new List());var FF; open(){return m.window.indexedDB.open('milestoneDB',version:1,onUpgradeNeeded:GF).then(HF);} GF( g){var h=(g.target as RC.Request).result;var i=h.createObjectStore(KB,autoIncrement:true);i.createIndex(rC,'milestoneName',unique:true);} HF( g){FF=g;var j=g.transaction(KB,'readonly');var l=j.objectStore(KB);var h=l.openCursor(autoAdvance:true).asBroadcastStream();h.listen((i){var o=new MB.oE(i.key,i.value);HB.add(o);});return h.length.then((IF){return HB.length;});} add( l, v){var g=new MB(l,v);var i=g.LE();var h=FF.transaction(KB,'readwrite');var o=h.objectStore(KB);o.add(i).then((j){g.tB=j;});return h.completed.then((IF){HB.add(g);return g;});} remove( g){var h=FF.transaction(KB,'readwrite');h.objectStore(KB).delete(g.tB);return h.completed.then((IF){g.tB=null;HB.remove(g);});} clear(){var g=FF.transaction(KB,'readwrite');g.objectStore(KB).clear();return g.completed.then((IF){HB.clear();});}}class VE extends EC with t{var JF;static final sC=new m.Element.tag('template'),tC=new m.Element.html('<li>\n                    <div is="x-milestone">\n                    </div>\n                  </li>'),uC=new m.DocumentFragment.html('''
          
          <div>
            <p>Enter a milestone</p>
            
            <input type="text" name="newMilestoneName">
            <input type="date" name="newMilestoneDate">
            <input type="time" name="newMilestoneTime">
            <button id="addbutton">+</button>
            
            <ul>
              <template></template>
            </ul>
          </div>
          <div>
            <button id="clearbutton">Clear</button>
            <p style="color:red"></p>
          </div>
          
        ''');var KF,LF;var MF;var NF,OF,PF;var QF;var RF; cC(){var SF=createShadowRoot("x-count-down");lC("x-count-down",new sB({"x-count-down":"[is=\"x-count-down\"]"}));JF=eC("x-count-down");RF=new pB(SF);SF.nodes.add(uC.clone(true));NF=SF.nodes[1].nodes[3];RF.listen(NF.onInput,(h){LC=NF.value;});RF.wB(()=>LC,(g){if(NF.value!=g)NF.value=g;},false,false);OF=SF.nodes[1].nodes[5];RF.listen(OF.onInput,(h){KC=OF.value;});RF.wB(()=>KC,(g){if(OF.value!=g)OF.value=g;},false,false);PF=SF.nodes[1].nodes[7];RF.listen(PF.onInput,(h){MC=PF.value;});RF.wB(()=>MC,(g){if(PF.value!=g)PF.value=g;},false,false);KF=SF.nodes[1].nodes[9];RF.listen(KF.onClick,(h){HC();});MF=SF.nodes[1].nodes[11].nodes[1];RF.FE(MF,()=>UB.HE,(RF){var TF;TF=sC.clone(true);RF.loop(TF,()=>UB.HB,(j,i,RF){var l=j[i];var UF,VF;VF=tC.clone(true);UF=VF.nodes[1];RF.wB(()=>l,(g){if(UF.xtag.RB!=g)UF.xtag.RB=g;},false,false);RF.YB(new WE()..host=UF);RF.addAll([new m.Text('\n                  '),VF,new m.Text('\n                ')]);});RF.addAll([new m.Text('\n                '),TF,new m.Text('\n              ')]);});LF=SF.nodes[3].nodes[1];RF.listen(LF.onClick,(h){clear();});QF=SF.nodes[3].nodes[3];var WF=RF.bC(()=>uB,false);QF.nodes.addAll([new m.Text(' '),WF,new m.Text(' ')]);RF.QB();} gC(){RF.insert();} kC(){RF.remove();RF=NF=OF=PF=KF=MF=LF=QF=null;}var XF=''; get uB{if(s){w(this,k.q,'errorMsg');}return XF;}set uB( g){if(CB(this)){n(this,k.q,'errorMsg',XF,g);}XF=g;}var LC="New Year's Day";var KC='2014-01-01';var MC='00:00:00'; HC(){var g=KC+' '+MC;var h=DateTime.parse(g);UB.HC(LC,h);} clear(){uB='';UB.clear();} fC(){UB.start().catchError((g){(m.query('#addbutton') as m.ButtonElement).disabled=true;(m.query('#clearbutton') as m.ButtonElement).disabled=true;uB=g.toString();});} jC(){UB.stop();}}class WE extends EC with t{var ZF;static final vC=new m.DocumentFragment.html('''
        <span></span> <button>-</button>
      ''');var aF;var bF;var cF; cC(){var dF=createShadowRoot("x-milestone");lC("x-milestone",new sB({"x-milestone":"[is=\"x-milestone\"]"}));ZF=eC("x-milestone");cF=new pB(dF);dF.nodes.add(vC.clone(true));bF=dF.nodes[1];var eF=cF.bC(()=>KE,false);bF.nodes.add(eF);aF=dF.nodes[3];cF.listen(aF.onClick,(g){OC();});cF.QB();} gC(){cF.insert();} kC(){cF.remove();cF=bF=aF=null;}var fF; get RB{if(s){w(this,k.q,'milestone');}return fF;}set RB( g){if(CB(this)){n(this,k.q,'milestone',fF,g);}fF=g;}var hF=''; get iF{if(s){w(this,k.q,'_displayString');}return hF;}set iF( g){if(CB(this)){n(this,k.q,'_displayString',hF,g);}hF=g;} get KE{if(RB.elapsed){iF='Huzzah for ${RB.fB}!';return iF;}var g=RB.PC;var h=g.inDays;var j=g.inHours.remainder(Duration.HOURS_PER_DAY);var i=g.inMinutes.remainder(Duration.MINUTES_PER_HOUR);var SB=g.inSeconds.remainder(Duration.SECONDS_PER_MINUTE);var v=(h==0)?'':'${h} days, ';var l=(j==0)?'':'${j} hours, ';var o=(i==0)?'':'${i} minutes, ';var JB='${SB} seconds';iF='${v} ${l} ${o} ${JB} until ${RB.fB}';return iF;} OC(){UB.OC(RB);}}class wC<NB> extends UD with t implements List<NB>{final  jF;wC([ g]):jF=g!=null?new List<NB>(g):<NB>[] ;factory wC.pE( g)=>new wC<NB>()..addAll(g); get length{if(s)w(this,k.q,'length');return jF.length;}set length( h){var i=jF.length;if(i==h)return;if(CB(this)){if(h<i){for(int g=i-1;g>=h;g-- ){n(this,k.PB,g,jF[g],null);}n(this,k.q,'length',i,h);}else{n(this,k.q,'length',i,h);for(int g=i;g<h;g++ ){n(this,k.VB,g,null,null);}}}jF.length=h;} operator[]( g){if(s)w(this,k.IB,g);return jF[g];}operator[]=( g, h){var i=jF[g];if(CB(this)){n(this,k.IB,g,i,h);}jF[g]=h;} sublist( h,[ g])=>new wC<NB>.pE(super.sublist(h,g)); add( h){var g=jF.length;if(CB(this)){n(this,k.q,'length',g,g+1);n(this,k.VB,g,null,h);}jF.add(h);} removeRange( h, g){if(g==0)return;TC.SD(this,h,g);if(CB(this)){for(int i=h;i<g;i++ ){n(this,k.PB,i,this[i],null);}}TC.RD(this,h+g,this,h,this.length-g-h);this.length=this.length-g;} toString(){if(s){for(int g=0;g<length;g++ ){w(this,k.IB,g);}}return jF.toString();}}typedef  gB<AB,u>();class ZB<AB,u> extends t implements Map<AB,u>{final  kF;var lF;var mF;ZB({ createMap}):kF=createMap!=null?createMap():new Map<AB,u>(){lF=new xC<AB,u>(this);mF=new yC<AB,u>(this);}factory ZB.qE( i,{ createMap}){var g=new ZB<AB,u>(createMap:createMap);i.forEach(( h, j){g[h]=j;});return g;} get keys=>lF; get values=>mF; get length{if(s)w(this,k.q,'length');return kF.length;} get isEmpty=>length==0; get isNotEmpty=>length!=0; nF( g)=>w(this,k.IB,g); oF(){w(this,k.q,'length');kF.keys.forEach(nF);} containsKey( g){if(s)nF(g);return kF.containsKey(g);} operator[]( g){if(s)nF(g);return kF[g];} operator[]=( h, g){var j=kF.length;var i=kF[h];kF[h]=g;if(CB(this)){if(j!=kF.length){n(this,k.q,'length',j,kF.length);n(this,k.VB,h,i,g);}else if(i!=g){n(this,k.IB,h,i,g);}}} putIfAbsent( g, j()){if(s)nF(g);var h=kF.length;var i=kF.putIfAbsent(g,j);if(CB(this)&&h!=kF.length){n(this,k.q,'length',h,kF.length);n(this,k.VB,g,null,i);}return i;} remove( g){if(s)nF(g);var h=kF.length;var i=kF.remove(g);if(CB(this)&&h!=kF.length){n(this,k.PB,g,i,null);n(this,k.q,'length',h,kF.length);}return i;} addAll( h)=>h.forEach((g,i){this[g]=i;}); clear(){var g=kF.length;if(CB(this)&&g>0){kF.forEach((i,h){n(this,k.PB,i,h,null);});n(this,k.q,'length',g,0);}kF.clear();} forEach( g( key, value)){if(s)oF();kF.forEach(g);} toString()=>xB.Maps.mapToString(this);}class xC<AB,u> extends xB.IterableBase<AB>{final  kF;xC(this.kF); get iterator=>new XE<AB,u>(kF);}class XE<AB,u> implements Iterator<AB>{final  kF;final  lF;var pF=false;XE( g):kF=g,lF=g.kF.keys.iterator; moveNext(){if(s)w(kF,k.q,'length');return pF=lF.moveNext();} get current{var g=lF.current;if(s&&pF)kF.nF(g);return g;}}class yC<AB,u> extends xB.IterableBase<u>{final  kF;yC(this.kF); get iterator=>new YE<AB,u>(kF);}class YE<AB,u> implements Iterator<u>{final  kF;final  lF;final  mF;var pF;YE( g):kF=g,lF=g.kF.keys.iterator,mF=g.kF.values.iterator; moveNext(){if(s)w(kF,k.q,'length');var h=lF.moveNext();var g=mF.moveNext();if(h!=g){throw new StateError('keys and values should be the same length');}return pF=g;} get current{if(s&&pF)kF.nF(lF.current);return mF.current;}}const ZE=const aE();typedef  LB( e);typedef  zC( changes);typedef  OB();typedef  AD();class nB{final oldValue;final newValue;final  changes;nB(this.oldValue,this.newValue,[this.changes]); operator==(g){return g is nB&&oldValue==g.oldValue&&newValue==g.newValue&&changes==g.changes;} get hashCode=>OD(oldValue,newValue,changes); toString(){if(changes!=null)return '#<ChangeNotification to ${newValue}: ${changes}>';return '#<ChangeNotification from ${oldValue} to ${newValue}>';}}class k{static const q=1;static const IB=2;static const VB=IB|4;static const PB=IB|8;final  type;final key;final oldValue;final newValue;k(this.type,this.key,this.oldValue,this.newValue); operator==(g){return g is k&&type==g.type&&key==g.key&&oldValue==g.oldValue&&newValue==g.newValue;} get hashCode=>PD(type,key,oldValue,newValue); toString(){var g;switch (type){case q:g='field';break;case IB:g='index';break;case VB:g='insert';break;case PB:g='remove';break;}return '#<ChangeRecord ${g} ${key} from ${oldValue} to ${newValue}>';}} BD(g, i,[ l]){if(g is t){var h=g;return yB(h,(o){i(new nB(h,h,o));});}var j=new oB(g,i,l);if(!j.qF()){return ED;}return j.rF;} yB( g, i){if(g.dB==null)g.dB=new AC();var h=g.dB.add(i);return h.remove;}CD(g){if(g is Map){var h=null;if(g is xB.SplayTreeMap){h=()=>new xB.SplayTreeMap();}else if(g is xB.LinkedHashMap){h=()=>new xB.LinkedHashMap();}return new ZB.qE(g,createMap:h);}if(g is Set)return new zB.rE(g);if(g is Iterable)return new wC.pE(g);return g;}class t{var dB;var cB;final  hashCode= ++t.DD;static var DD=0;} CB( g)=>g.dB!=null&&g.dB.head!=null; get s=>aB!=null; w( g, h,i)=>aB.sF(g,h,i); n( g, j,l, h, i){if((j&(k.VB|k.PB))==0){if(h==i)return;}if(WB==null){WB=[] ;QD(FD);}if(g.cB==null){g.cB=[] ;WB.add(g);}g.cB.add(new k(j,l,h,i));} ED(){}var aB;var SC=100;var WB;var XB; FD(){var o=0;while (WB!=null||XB!=null){var j=WB;WB=null;var i=XB;XB=null;if(o++ ==SC){GD(j,i);return;}if(j!=null){for(var h in j){var JB=h.cB;h.cB=null;for(var g=h.dB.head;g!=null;g=g.next){var l=g.value;try {l(JB);}catch (SB,v){hB(SB,v,l,'from ${h}');}}}}if(i!=null){i.forEach((mE,QC){QC.tF();});}}} GD( l, j){var g=[] ;if(l!=null){for(var i in l){var JB=i.cB;g.add('${i} ${JB}');}}if(j!=null){for(var o in j.values){var h=o.tF();if(h!=null)g.add('${o} ${h}');}}WB=null;XB=null;var v='exceeded notifiction limit of ${SC}, possible ' 'circular reference in observer callbacks: ${g.take(10).join(", ")}';JD(v);}class oB{static var HD=0;final  uF= ++oB.HD;final  vF;final  wF;final  xF;final  yF=new Map();final  zF=[] ;var AG=false;var BG;oB(this.vF,this.wF,this.xF); toString()=>xF!=null?'<observer ${uF}: ${xF}>':'<observer ${uF}>'; qF(){var h=aB;aB=this;try {BG=vF();if(BG is Iterable&&BG is !List&&BG is !t){BG=(BG as Iterable).toList();}}catch (g,i){hB(g,i,vF,'from ${this}');BG=null;}yF.forEach(CG);yF.clear();assert(aB==this);aB=h;DG();return zF.length>0;} EG( i){try {wF(i);}catch (g,h){hB(g,h,wF,'from ${this}');}} DG(){var g=BG;if(g is !t)return;zF.add(yB(g,(h){EG(new nB(g,g,h));}));} sF( o, v,g){var i=yF.putIfAbsent(o,()=>new Map());try {var h=i[g];if(h==null)h=0;i[g]=h|v;}catch (j,l){hB(j,l,g,'hashCode or operator == from ${this}');}} CG( i, j){zF.add(yB(i,(l){if(AG)return;for(var g in l){var h=j[g.key];if(h!=null&&(h&g.type)!=0){AG=true;if(XB==null){XB=new xB.SplayTreeMap();}XB[uF]=this;return;}}}));} rF(){for(var g in zF){g();}AG=false;} tF(){if(!AG)return null;var g=BG;rF();qF();try {if(g==BG)return null;}catch (i,j){hB(i,j,g,'operator == from ${this}');return null;}var h=new nB(g,BG);EG(h);return h;}}typedef  ID( message);var JD=(g)=>print(g);typedef  KD(error,stackTrace,obj, message);var hB=LD; LD(i,g,h, j){print('web_ui.observe: unhandled error calling ${h} ${j}.\n' 'error:\n${i}\n\nstack trace:\n${g}');}class aE{const aE();}class zB<DB> extends TD with t implements Set<DB>{final  FG;final  GG;zB({ createMap}):FG=createMap!=null?createMap():new Map<DB,Object>(),GG=createMap;factory zB.rE( g,{ createMap}){return new zB<DB>(createMap:createMap)..addAll(g);} contains( g){if(s)w(this,k.IB,g);return FG.containsKey(g);} add( g){var h=FG.length;FG[g]=const Object();if(h!=FG.length){n(this,k.q,'length',h,FG.length);n(this,k.VB,g,null,g);}} remove( g){if(s)w(this,k.IB,g);var h=FG.length;FG.remove(g);if(h!=FG.length){if(CB(this)){n(this,k.PB,g,g,null);n(this,k.q,'length',h,FG.length);}return true;}return false;} clear(){if(CB(this)){for(var g in FG.keys){n(this,k.PB,g,g,null);}n(this,k.q,'length',FG.length,0);}FG.clear();} get length{if(s)w(this,k.q,'length');return FG.length;} get isEmpty=>length==0; get iterator=>new bE<DB>(this); addAll( g)=>g.forEach(add); difference( i){var h=new zB<DB>(createMap:GG);for(DB g in this){if(!i.contains(g))h.add(g);}return h;} toString(){if(s){for(DB g in FG.keys){w(this,k.IB,g);}}return FG.keys.toSet().toString();}}class bE<DB> implements Iterator<DB>{final  HG;final  IG;var JG=false;bE( g):HG=g,IG=g.FG.keys.iterator; moveNext(){HG.length;return JG=IG.moveNext();} get current{var g=IG.current;if(s&&JG)w(HG,k.IB,g);return g;}}class MD{}class ND{}class FB<GB>{var KG;var LG;var MG;var NG;FB.sE( g,this.MG):NG=g{if(MG!=null)MG.OG++ ;} get next=>LG; get value=>NG;set value( g)=>NG=g; PG( g, h){LG=h;KG=g;if(g!=null)g.LG=this;if(h!=null)h.KG=this;return this;} append( g)=>new FB<GB>.sE(g,MG).PG(this,LG); remove(){if(MG==null)return;MG.OG-- ;if(KG!=null){KG.LG=LG;}else{MG.QG=LG;}if(LG!=null){LG.KG=KG;}else{MG.RG=KG;}LG=null;KG=null;MG=null;}}class AC<GB> extends xB.IterableBase<GB>{var QG;var RG; get length=>OG;var OG=0;AC(){} get head=>QG; add( h){var g=new FB<GB>.sE(h,this);if(RG==null)return QG=RG=g;return RG=g.PG(RG,null);} addLast( g)=>add(g); addAll( g)=>g.forEach(add); get iterator=>new cE<GB>(this);}class cE<GB> implements Iterator<GB>{var SG;var MG;var TG;var UG=-1;cE(this.MG){SG=new List<FB>(MG.length);var h=0;var g=MG.head;while (g!=null){SG[h++ ]=g;g=g.next;}} get current=>TG; moveNext(){do{UG++ ;}while(UG<SG.length&&SG[UG].MG!=MG);if(UG<SG.length){TG=SG[UG].value;return true;}else{TG=null;return false;}}}iB(h,g)=>h.hashCode*31+g.hashCode;OD(h,g,i)=>iB(iB(h,g),i);PD(g,i,h,j)=>iB(iB(g,i),iB(h,j)); QD( h()){var g=new nE.ReceivePort();g.receive((i,j){g.close();h();});g.toSendPort().send(null);}class TC{static  RD( o, g, v, i, l){if(g==null)g=0;if(i==null)i=0;if(g<i){for(int h=g+l-1,j=i+l-1;h>=g;h-- ,j-- ){v[j]=o[h];}}else{for(int h=g,j=i;h<g+l;h++ ,j++ ){v[j]=o[h];}}}static  SD( j, h, g){if(g<0){throw new ArgumentError("negative length ${g}");}if(h<0){var i="${h} must be greater than or equal to 0";throw new RangeError(i);}if(h+g>j.length){var i="${h} + ${g} must be in the range [0..${j.length})";throw new RangeError(i);}}}abstract class TD extends xB.IterableBase<dynamic>{}abstract class UD extends xB.ListMixin<dynamic>{} VD(i, g,[ h]){var j=i is MD;if(h==null){h=i.toString();}if(!j&&g is m.Text){g.text=h;}else{var l=g;g=j?new m.Element.html(h):new m.Text(h);l.replaceWith(g);}return g;} WD(g){if(g is ND)return g.toString();g=g.toString();return YD(g)?g:'#';}const XD=const["http","https","ftp","mailto"]; YD( h){var g=Uri.parse(h).scheme;if(g=='')return true;return XD.contains(g.toLowerCase())||"MAILTO"==g.toUpperCase();}abstract class bB{ QB(){} insert(); remove();}class dE extends bB{final  dC;var VG;final  listener;dE(this.dC,this.listener); insert(){VG=dC.listen(listener);} remove(){VG.cancel();VG=null;}}class eE extends bB{final exp;final  action;final  isFinal;var BB;eE(this.exp,this.action,this.isFinal); insert(){if(isFinal){action(new nB(null,exp()));}else if(BB!=null){throw new StateError('binding already attached');}else{BB=qB(exp,action,'generic-binding');}} remove(){if(!isFinal){BB();BB=null;}}}class fE extends bB{final  mC;final  JC;final  hC;final  isFinal;var BB;fE(this.JC,this.mC,this.hC,this.isFinal); WG(g){mC(hC?WD(g):g);} insert(){if(isFinal){WG(JC());}else if(BB!=null){throw new StateError('data binding already attached.');}else{BB=qB(JC,(g)=>WG(g.newValue),'dom-property-binding');}} remove(){if(!isFinal){BB();BB=null;}}}class gE extends bB{final YB;gE(this.YB); QB(){YB..cC()..GE()..EE();} insert(){YB..fC()..gC();} remove(){YB..kC()..jC();}}class pB extends bB{final  NC;final  children=[] ;final  nodes=[] ;pB(this.NC); listen( i, h){children.add(new dE(i,(g){h(g);eD();}));} bC( h,i){var g=new m.Text('');children.add(new eE(()=>'${h()}',(j){g=VD(h(),g,j.newValue);},i));return g;} wB(g,j,h,[i=false]){children.add(new fE(g,j,i,h));} FE( h,g,i){children.add(new aD(h,g,i));} loop( h,g,i){children.add(new hE(h,g,i));} YB( g){children.add(new gE(g));} add( g)=>nodes.add(g); addAll( g)=>nodes.addAll(g); QB(){for(var g=0,h=children.length;g<h;g++ ){children[g].QB();}} insert(){for(var g=0,h=children.length;g<h;g++ ){children[g].insert();}} remove(){for(var g=children.length-1;g>=0;g-- ){children[g].remove();}children.clear();}}abstract class UC extends pB{final exp;var BB;UC( g,this.exp):super(g); QB(){} insert(){super.QB();if(nodes.length>0){var i=NC.parentNode;var j=NC.nextNode;for(var g=0,h=nodes.length;g<h;g++ ){i.insertBefore(nodes[g],j);}}super.insert();} remove(){super.remove();for(var g=nodes.length-1;g>=0;g-- ){nodes[g].remove();}nodes.clear();}}typedef  ZD( template);class aD extends UC{var vB=false;final  aC;aD( h,g,this.aC):super(h,g); insert(){BB=qB(exp,(g){if(!vB&&g.newValue){aC(this);super.insert();vB=true;}else if(vB&&!g.newValue){super.remove();vB=false;}},'conditional-binding');} remove(){super.remove();BB();BB=null;}}typedef  bD( list, index, template);class hE extends UC{final  iC;hE( h,g,this.iC):super(h,g); insert(){BB=qB(exp,(i){super.remove();var h=i.newValue;for(int g=0;g<h.length;g++ ){iC(h,g,this);}super.insert();},'loop-binding');} remove(){super.remove();BB();BB=null;}}var VC=false; cD(g, o,[ l]){if(VC)return BD(g,o);if(o==null)return (){};if(jB==null)jB=new AC<kB>();var i;var h=EB.iD;if(g is YC){i=(g as YC).XG;}else if(g is Function){i=g;try {var j=g();if(j is List){h=EB.lB;}else if(j is Iterable){h=EB.lB;i=()=>g().toList();}else if((j is xB.LinkedHashMap)||(j is xB.SplayTreeMap)){h=EB.DC;}else if(j is Map){h=EB.CC;}}catch (JB,QC){print('error: evaluating ${l!=null?l:"<unnamed>"} ' 'watcher threw error (${JB}, ${QC})');}}else if(g is List){i=()=>g;h=EB.lB;}else if(g is Iterable){i=()=>g.toList();h=EB.lB;}else if((g is xB.LinkedHashMap)||(g is xB.SplayTreeMap)){i=()=>g;h=EB.DC;}else if(g is Map){i=()=>g;h=EB.CC;}var v=dD(h,i,o,l);var SB=jB.add(v);return SB.remove;} dD( j, g, i, h){switch (j){case EB.lB:return new iE(g,i,h);case EB.DC:return new kE(g,i,h);case EB.CC:return new jE(g,i,h);default:return new kB(g,i,h);}} qB(h,i,[j]){var l=cD(h,i,j);var g=h;if(g is Function){g=g();}if(g is Iterable&&g is !List){g=g.toList();}i(new nB(null,g));return l;}var jB;class kB{final  IC;final  XG;final  YG;var ZG;kB(this.XG,this.YG,this.IC){ZG=XG();} toString()=>IC==null?'<unnamed>':IC; DE(){var g=aG();if(bG(g)){var h=ZG;cG(g);YG(new nB(h,g));return true;}return false;} bG(g)=>ZG!=g; cG(g){ZG=g;}aG(){try {return XG();}catch (g,h){print('error: evaluating ${this} watcher threw an exception (${g}, ${h})');}return ZG;}}final  WC=10; eD(){if(jB==null)return;var g;var h=0;do{g=false;for(var i in jB){if(i.DE()){g=true;}}}while(g&& ++h<WC);if(h==WC){print('Possible loop in watchers propagation, stopped dispatch.');}}typedef  XC<fD>();typedef  gD<fD>( value);class YC<fD>{}class iE<fD> extends kB{iE(g, i, h):super(g,i,h){cG(aG());} bG( g){return BC(ZG,g);} cG(g){ZG=new List<fD>.from(g);}}class jE<rB,hD> extends kB{jE(g, i, h):super(g,i,h){cG(aG());} bG( g){var i=ZG.keys;if(i.length!=g.keys.length)return true;var j=i.iterator;while (j.moveNext()){var h=j.current;if(!g.containsKey(h))return true;if(ZG[h]!=g[h])return true;}return false;} cG(g){ZG=new Map<rB,hD>.from(g);}}class kE<rB,hD> extends kB{kE(g, i, h):super(g,i,h){cG(aG());} bG( g){return BC(g.keys,ZG.keys)||BC(g.values,ZG.values);} cG(g){ZG=new xB.LinkedHashMap.from(g);}} BC( i, j){var h=i.iterator;var g=j.iterator;while (h.moveNext()){if(!g.moveNext())return true;if(h.current!=g.current)return true;}return g.moveNext();}class EB{final dG;const EB.tE(this.dG);toString()=>'Enum.${dG}';static const lB=const EB.tE('LIST');static const CC=const EB.tE('HASH_MAP');static const DC=const EB.tE('ORDERED_MAP');static const iD=const EB.tE('OTHER');}abstract class EC implements m.Element{var eG;var fG;var gG={};var hG=new sB({}); eC( g)=>hG; lC( h,var g){hG=g;} get host{if(eG==null)throw new StateError('host element has not been set.');return eG;}set host( g){if(g==null){throw new ArgumentError('host must not be null.');}var h=g.xtag;if(h!=null&&h!=g){throw new ArgumentError('host must not have its xtag property set.');}if(eG!=null){throw new StateError('host can only be set once.');}g.xtag=this;eG=g;}createShadowRoot([ g]){var h=iG();if(g!=null){gG[g]=h;}return h;}iG(){if(ZC){return host.createShadowRoot();}if(fG==null)fG=[] ;fG.add(new m.DivElement());return fG.last;} GE(){} fC(){} jC(){} EE(){if(ZC)return;if(fG.length==0){throw new StateError('Distribution algorithm requires at least one shadow' ' root and can only be run once.');}var j=fG;var g=j.removeLast();var v=g;var o=new List.from(nodes);var l=[] ;var JB=[] ;while (true){o=jG(g,o);var h=g.query('shadow');if(h!=null){if(j.length>0){g=j.removeLast();l.add(h);JB.add(g);}else{GC(h,o);break;}}else{break;}}for(int i=0;i<l.length;i++ ){var h=l[i];var g=JB[i];GC(h,g.nodes);}nodes.clear();nodes.addAll(v.nodes);for(var SB in gG.keys){if(gG[SB]==v){gG[SB]=this;break;}}} jG( v, j){for(var g in v.queryAll('content')){if(!kD(g))continue;var i=g.attributes['select'];if(i==null||i=='')i='*';var h=[] ;var o=[] ;for(var l in j){(jD(l,i)?h:o).add(l);}if(h.length==0){h=g.nodes;}GC(g,h);j=o;}return j;}static  jD( h, g){if(h is !m.Element)return g=='*';return (h as m.Element).matches(g);}static  FC( g)=>g.tagName=='CONTENT'||g.tagName=='SHADOW';static  kD( g){assert(FC(g));for(g=g.parent;g!=null;g=g.parent){if(FC(g))return false;}return true;}static  GC( g, h){assert(FC(g));g.parent.insertAllBefore(h,g);g.remove();} get nodes=>host.nodes; replaceWith( g){host.replaceWith(g);} remove()=>host.remove(); get nextNode=>host.nextNode;set text( g){host.text=g;} contains( g)=>host.contains(g); insertBefore( g, h)=>host.insertBefore(g,h); insertAllBefore( g, h)=>host.insertAllBefore(g,h); get attributes=>host.attributes; get children=>host.children; clone( g)=>host.clone(g); get parent=>host.parent; get parentNode=>host.parentNode; get nodeValue=>host.nodeValue; get id=>host.id;set id( g){host.id=g;} set innerHtml( g){host.innerHtml=g;} get tagName=>host.tagName; matches( g)=>host.matches(g); query( g)=>host.query(g); queryAll( g)=>host.queryAll(g); get pD=>host.pD; get qD=>host.qD; get tD=>host.tD; rD( g)=>host.rD(g); sD( g)=>host.sD(g); wD( g)=>host.wD(g); xD( g)=>host.xD(g); BE( h, g)=>host.BE(h,g);get nD=>host.nD; get oD=>host.oD; get firstChild=>host.firstChild; get localName=>host.localName; get uD=>host.uD; get vD=>host.vD; mD( i, g,[ h]){host.mD(i,g,h);} yD( g)=>host.yD(g); zD( i, g,[ h]){host.zD(i,g,h);} AE( g, h)=>host.AE(g,h);get xtag=>host.xtag;set xtag(g){host.xtag=g;} append( g)=>host.append(g); get onClick=>host.onClick; get onInput=>host.onInput;}class sB{final  kG;sB(this.kG); operator[]( g)=>kG[g];}var lD=false; get ZC=>lD&&m.ShadowRoot.supported;//@ sourceMappingURL=count_down.html_bootstrap.dart.map
